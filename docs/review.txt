===========================================
eZ-Publish JavaScript REST-Prototype Review
===========================================

:Author:   Jakob Westhoff
:Revision: In-Progress
:Date:     2013-03-20

.. contents:: Table of contents

General Remarks
===============

- Usage of ``'use strict';`` throughout the library is a very good thing, and
  should be continued
- A project specific *jslint/jshint* configuration should be created
    
    - After a general coding style has been defined it should be made sure that
      it is adhered to throughout the project

- Constructors should always begin with an uppercase letter.

    - As JavaScript does not provide any structural way of differentiating
      between pseudo-classes and other data types, using the uppercase syntax
      is mostly the only more or less standard way of doing so.

- Files should be named after the exported Symbol/Module/Widget/...

    - This does include the Upper/Lowercase of the exported Symbol
    - Currently every file starts with a lower case (constructor functions as
      well as other modules).

        - The only exception I could find is the ``CAPI.js`` entry point.

- All used member variables of prototype should be initialized

    - This can happen either inside the constructor function itself (mostly
      preferred), or on the prototype itself::

        var SomeConstructor = function() {
            this.someProperty = null;
            this.someOtherProperty = [];
            //...
        }

        // or

        SomeConstructor.prototype.someProperty = null;

        // Can lead to problems with pre initialized objects/arrays, which are
        // passed by reference automatically. Therefore the in constructor
        // declaration is preferred
        // 
        // In this case all instances would essentially share the same array
        // instead of encapsulating their state in per instance.
        SomeConstructor.prototype.someOtherProperty = []

    - The reason, why empty properties should be declared as well as pre-
      initialized ones is that there is not other way to create a doc-block for
      them otherwise in JavaScript.

- Added external dependency ``date.format.js``.

    - If possible external dependencies should be avoided (as stated in the
      design)
    - Something small like this ``date.format.js`` could be acceptable, if it
      is really needed.

        - Even though much bigger a better date formatting/handling library in
          general is `moment.js`__

        - ``date.format.js`` modifies the ``Date.prototype``, which is
          considered a bad practice

    - It seems to be only used to retrieve the ISO date time representation format

        - This could easily be implemented in a few lines of code, without the
          need to pull in an external dependency like this.

__ http://momentjs.com/

- Object literals defining HTTP-Header information should always specify every
  key (header-name) as a string.

    - HTTP-Headers often have dashes (``-``) inside their naming, which makes
      the usage of stringified keys a necessity anyways. To ease readability
      a mixture of stringified and non stringified keys should not be used
      inside of those objects. 

- Callbacks always need to be called using two arguments (``error`` and
  ``result``). See the review of `connections/connectionXHR.js`_ for details
  about the current problematic implementation.


Module Pattern
==============

The *Module Pattern* is currently used to divide modules from each other and
isolate scopes. There are certain things, which need to be thought about
regarding this issue, which this section documents.

Module Pattern variations and alternatives
------------------------------------------

This section tries to clear up, what it exactly meant by the "Module Pattern".

The *Module Pattern* is an encapsulation of different code modules/segments
into an anonymous self calling function, to isolate the modules scope from the
rest of the application. It is currently used throughout the application in the
following way::

    var ExportedClassOrModule = (function(globalDependency1, ...) {
        var internalClassOrModuleName = ...

        return internalClassOrModuleName;
    })(globalDependency1, ...);

This is a viable approach, however the naming is not ideal here. The
``internalClassOrModule`` should be named exactly like the
``ExportedClassOrModule`` in order to minimize confusion. Otherwise it is hard
to tell which class or module is currently utilized, as different aliases exist
for it depending on the context it is used in.

Another disadvantage of this approach is the fact that only one symbol may be
exported per module. As this is however the case with most object oriented
applications anyways, it is mostly not a big problem.

Furthermore pseudo-class constructors should **always** begin with an uppercase
letter (which is not the case in certain situations regarding the
``internalClassOrModule`` naming).

A possible alternative usage of the *Module Pattern* is::

    var exportedNamesapce.exportedSubNamespace = new (function(globalDependency) {
        // module internal code

        this.someExportedFunctionOrObject = ...
        this.anotherExportedFunctionOrObject = ...
    })(globalDependency);

Even though this provides further visibility to the exported namespace, as well
as the chance to export more than one symbol, it might quite easily irritate
developers, by the usage of the ``new`` operator in conjunction with an
anonymous function.

The third and mostly used alternative is the following::

    (function(global, globalDependency1, ...) {
        // Module code is put inside here
        global.someExportedThing = ...
        // or
        window.someExportedThing = ...
    })(window, globalDependency1, ...);

This approach, even though seeming to be the most readable and clear one at
first has its drawbacks as well. The exported symbol is not easily identifiable
immediately. Furthermore the direct use of ``window`` should be avoided, to
allow for easier usage inside non-browser JavaScript environments, like nodejs.

Which one should be used?
-------------------------

The current use case of mainly exporting one symbol per module (aka.
a constructor function) steers us into the direction of the first and already
used approach. Nevertheless the naming of internal versus external symbols
should definitely be unified.

Furthermore we should discuss about using CommonJS/AMD (most likely
a convenience syntax for both) to handle dependencies and/or modules. As the
CAPI is an independent library it can easily use those tools to help with
building, dependency management and module definition. If this path is chosen
the module-structure and exporting of symbols would need a slight change.

Detailed Analysis
=================

``CAPI.js``
-----------

General
^^^^^^^

- internal/external symbol mismatch
- uninitialized properties: ``contentService_``
- As the current CAPI will only be capable of interacting with the
  REST-Service, the ``RestConnectionManager`` should most likely be simply
  called ``ConnectionManager`` due to readability reasons.

API/Design
^^^^^^^^^^

- ``ConnectionType`` should not be injected, but determined through the
  ``ConnectionManager``, as described in the design document section **Feature
  Detection**.
- ``AuthenticationAgent`` is not supposed to be a literal object. See the newly
  added section **AuthenticationAgents** for details regarding the used
  interface.

``connectionManager.js``
------------------------

General
^^^^^^^

- internal/external symbol mismatch
- Re-declaration of ``endPointUrl`` and ``authenticationAgent`` variables.

    - Most likely a leftover from a optional argument refactoring?
    - Nevertheless function arguments should never be redeclared, even if they
      are overwritten due to optional arguments


API/Design
^^^^^^^^^^

- As noted in the `CAPI.js`_ section the ``connectionType`` should not be
  injected, but determined using the ``isCompatible`` feature detection of the
  ``Connection`` interface.
- A ``Connection`` is not supposed to know about the ``AuthenticationAgent``

    - As described in the sections **Authentication**,  **Initial
      Authentication** and **Request Modification** the ``ConectionManager`` is
      supposed to take care about the handling of authenticated
      requests/connections

- As described by the **Raw Request Interface** section of the design only the
  ``headers`` part of the ``ConnectionManager#request`` method should be
  optional. Every other argument is supposed to be mandatory
    
    - After a further look it might make sense to declare the ``bodyObject``
      property optional as well.

        - Changing the API to utilize the new ``Request`` struct here could
          solve all those problems as well (see the note below.)

    - Stated in the same section is the possibility to create further methods
      as shortcuts for often used requests.

        - This should be used to define more appropriate methods for really
          needed cases.

- As specified by the design the method of the ``Connection`` should be
  ``execute``, not ``sendRequest``.

    - Of course this is not final. I actually start to like ``sendRequest``
      better, since the ``Request`` has now been renamed to ``Connection``.
    - Nevertheless every ``Connection`` needs to adhere to the same interface,
      therefore the design document should be adapted accordingly, if
      a renaming is done.

    ..note:: The adaption of the design document with regards to the
        ``AuthenticationAgent`` interface has created the need for a ``Request``
        struct. Therefore the *old* ``Request`` is now named ``Connection``.
        Furthermore this ``Connection`` takes an instance of the new ``Request``
        struct, which defines what kind of request should be executed. It needs to
        be discussed if the ``ConnectionManager#request`` signature is changed to
        utilze this ``Request`` struct as well.

- Queuing/Suspending requests during authentication needs to be implemented
  (already marked as TODO)


``services/contentService.js``
------------------------------

General
^^^^^^^

- internal/external symbol mismatch
- The naming of the ``root`` method is irritating. I would call it ``getRoot``,
  ``fetchRoot`` or ``loadRoot``

    - This method should furthermore most likely be a private method of the
      service. It then should be used by an abstraction to store and handle
      auto discovered URLs and media-types. (See `URL-Auto-Discovery`_ as well
      as `DiscoveryService`_ for details)

API/Design
^^^^^^^^^^

Struct Creation
~~~~~~~~~~~~~~~

This section does contain notes about the current creation of structs:

``newContentUpdateStruct``, ``newContentMetadataUpdateStruct``,
``newContentCreateStruct``, ``newLocationCreateStruct``

- Struct factories do not need to be asynchronous

    - I currently do not see where this struct creation might be asynchronous.
      Maybe there is one I currently don't see. We should discuss your reasons
      for making this calls asynchronous.

    - In general I tend to do object creation as synchronous as possible, as it
      simplifies APIs and their usage significantly. If asynchronous
      initialization is needed I tend to do that in a lazy manner, like with
      the ``AuthenticationAgents`` to have a simpler API.

- I currently don't see a technical reason, why the creation of the structs is
  executing using factory functions at all. Why not simply allow the user to
  inject/specify them using a usual ``new`` operation, instead of the factory?
  Is there a reason I don't currently see for that? Besides the fact that it is
  done in the PAPI as well? Actually after a quick look into those methods in
  the PAPI I am not 100% sure, why it is done there as well. Therefore I maybe
  overlooking something here.

URL-Auto-Discovery
~~~~~~~~~~~~~~~~~~

This section contains notes about the url-auto-discovery rest api as well as
its usage.

- The REST-API utilizes URL-Auto-Discovery

    - This implies that the ids to all requested documents always need to be
      the full relative url
    - However, not every method of the API does request a user-specific
      resource.

        - Example: The user does not care about, where the ``loadSections``
          method does retrieve the sections, neither is he/she supposed to care
          about this.

            - The method should not use a hard coded url either.
            - The API is supposed to utilize the url it has discovered, by
              requesting the root entrypoint into the application, which by the
              way is the only url which should be hardcoded.

                - The discovered urls should of course be stored once the
                  initial root look up has been done.
                - The root request needed to discover the proper API should be
                  issued automatically if it hasn't been done, but
                  a corresponding url is needed.

        - The same is true of course for methods like ``createSection``

            - The input data is needed of course, but the target url can and
              should be autodiscovered.

        - All of this is true for every part of the REST-API of course, like
          content-type-groups, Content, Versions, ...

            - The CAPI should auto discover all urls, which represent
              collections and entry points
            - Direct document based access is of course always done using the
              full url as an id to the resource
            - If a certain auto-discovery entry point does not exist within the
              REST-API it should be considered a bug and added to the backend.

                - I wasn't able to find a reference to ``/content/typegroups``
                  for example anywhere. (I might be wrong about this ;)

- Hard coded ``media-type``

    - ``media-type`` properties should not be hardcoded as well

        - All ``media-types`` used by the different entry points are provided
          by the auto-discovery information as well. They should therefore be
          stored and utilized, as they may change in the future.

DiscoveryService
~~~~~~~~~~~~~~~~

- The design document has been updated to contain information about
  a ``DiscoveryService``, which should be created to take care about the
  discovery, management and provisioning of urls and media-types.


``connections/connectionXHR.js``
--------------------------------

General
^^^^^^^

- internal/external symbol mismatch
- Please take a look at the changed design regarding ``Request`` structs and
  the therefore changed signature of the ``Connection`` interface.


API/Design
^^^^^^^^^^

- As mentioned before the ``AuthenticationAgent`` is is seperate component,
  which is utilized by the ``ConnectionManager``. A ``Connection`` should not
  even know about the ``AuthenticationAgent`` used. It is the most low level
  interface to communicate with the backend, based on a given ``Request``

    - Therefore The ``Connection`` implementation should not worry at all about
      authentication. It can assume the connection is already authenticated, or
      the ``Request`` struct provided for execution does already contain all
      the necessary information to properly handle the authentication.
    - In order to not depend on the "basic-auth" functionality of certain
      XHR-Implementation the corresponding headers will be generated by the
      corresponding ``AuthenticationAgent``, to be injected into the
      ``Request`` before processing it.
    - All of this is happening before the ``Request`` reaches the
      ``Connection`` interface.

- The ``Request`` should not be modified by the ``Connection`` in any way. It
  should simply be executed and its response handled.
    
    - The only exception, as mentioned in the design document is the
      ``X-HTTP-Method-Override`` header, should it become a necessity.

- One of the reasons behind the different ``Connection`` implementations is the
  seperation of concerns regarding the different browser implementations.
  Currently the ``conectionXHR.js`` handles ``XmlHttpRequests`` as well as
  Microsofts legacay ``XMLHTTP``.

    - Consult the design document about **Connections** as well as the
      **ConnectionFeatureFactory** for a better understanding of the
      ``Connection`` interface concept.

    - The following incomplete example of a possible correct implementation
      structure for this kind of connection is provided below::

        var XmlHttpRequestConnection = function() {
            this.xhr_ = new XmlHttpRequest();
        };

        XmlHttpRequestConnection.isCompatible = function() {
            return !!window.XMLHttpRequest;
        };

        XmlHttpRequestConnection.prototype.execute = function(request, callback) {
            // Use this.xhr_ to execute the request and properly call the callback upon completion or error
        };

        // ---

        var MicrosoftXmlHttpConnection = function() {
            this.xhr_ = new ActiveXObject("Microsoft.XMLHTTP");
        };

        MicrosoftXmlHttpConnection.isCompatible = function() {
            return (
                !window.XMLHttpRequest
                && !!window.ActiveXObject
            );
        };

        MicrosoftXmlHttpConnection.prototype.exeucte = function(request, callback) {
            // Mostly the same as with the XmlHttpRequestConnection
            // X-HTTP-Method-Override needs to kick in here for request methods other then GET and POST
        };

    - If there is a lot code duplication between different connections
      aggregation may be used for code reuse

        - Another solution is to isolate the shared code into its own class,
          which is instantiated and provided to the ``Connection`` during
          construction.

    - Deviding the different connection types in such a strict way is not only
      a clean approach from an ood point of view, but allows us to utilize the
      full potential of modern browsers with regards to
      Cross-Origin-Domain-Requests (``XmlHttpRequest2`` and
      ``XDomainRequest``), while still having a clean ood structure. (See the
      Design document regarding the **ConnectionFeatureFactory** for an idea
      about structuring and aggregation.)

- HTTP-Statuscodes other than the 2xx range do not indicate a fatal connection
  error

    - They should simply be passed to ``Response`` data structure, which is
      given to the callback
    - Only real connection error (timeouts, unreachable hosts, ...) are
      considered fatal and are therefore communicated as error to the callback.

- The result callback is not properly called

    - As defined inside the design document **every** callback inside the CAPI
      is supposed to be created using the following form::

        function callback(error, result) {}

    - The ``error`` property is filled with an error object if a fatal
      error has occurred

        - If the execution happened error free the supposed ``error`` value
          is ``false``

    - The ``result`` property does contain an arbitrary data value
      reflecting the result of the operation (Scalar, Array, Object, ...).

        - Only one ``result`` property is allowed due to promise
          transformation constraints.

    - See the **Combining Callbacks and Promises** section for details about
      the requirements and restrictions applied to callbacks.

    - To minimize complexity throughout the library internal as well as
      external callbacks should adhere to the same principles.

    - Disregarding the missing ``error`` property the callback is nevertheless
      called the wrong way, as no ``Response`` object is created and used. This
      is necessary, as stated in the design, to encapsulate all different kinds
      of request response information property, for the high-level api to
      handle, like the HTTP-Status-Code, Response-Headers and the body.


Further Remarks / Future Ideas / To be discussed
================================================

- Should the CAPI be nodejs compatible as well?
- As the CAPI is supposed to be independent of the rest of the Admin interface,
  should it utilize CommonJS/AMD module capabilities to ease the build process?
- Usage of a ``package.json`` and/or ``component.json`` definition could help
  with the dependency management, like Q.js (promise library).
- Currently the ``AuthenticationAgents`` as well as the ``ConnectionManager``
  need a way to select a proper ``Connection``. As stated in the design
  document the ``ConnectionManager`` should be responsible for the selection in
  the first prototype. For a second iteration a refactoring into something like
  a ``ConnectionFeatureFactory`` is suggested. With the added
  ``AuthenticationAgents`` complexity, maybe this kind of factory should be
  introduced directly, to minimize copy&paste development from the start.

  - I documented a way to implement this thing inside the design document. It
    should not be much effort to create something like this.

- It needs to be discussed at which point full qualified urls (fqurl) are
  specified and at which points relative ones are specified. Some questions to
  think about this problem:

    - Should the ConnectionManager already get fqurls?
    - Should the Connection get fqurls?

        - This would imply, that the ``Request`` struct does need to contain
          fqurls.

    - Should the Request simply know the *rest api entrypoint url* and have the
      functionality to create a fqurl from a relative one?

- The REST-API uses non-standard HTTP-Methods, like ``PUBLISH`` and ``MOVE``,
  which is fine in accordance with the RFC. Nevertheless it is not yet
  reflected by the design document. It is a minor change, but should be made in
  the near future.
